{
  "contest": {
    "id": "Exam1",
    "contestName": "Code Area",
    "date": "15 Tháng 1, 2025",
    "numberOfTeams": 248,
    "problemStatus": {
      "solved": 3,
      "attempted": 2,
      "wrongAnswer": 1,
      "unattempted": 6
    },
    "problems": [
      {
        "id": "A1",
        "name": "Tính Giai Thừa",
        "description": "Tính giai thừa của một số nguyên không âm",
        "points": 100
      },
      {
        "id": "B1",
        "name": "Sắp Xếp Hai Mảng",
        "description": "Gộp và sắp xếp hai mảng tăng dần",
        "points": 150
      },
      {
        "id": "C1",
        "name": "Phương Trình Bậc Hai",
        "description": "Tìm nghiệm phương trình bậc hai (xử lý cả trường hợp bậc nhất và vô số nghiệm)",
        "points": 200
      },
      {
        "id": "D1",
        "name": "Đổi Tiền",
        "description": "Tối ưu số tờ tiền cần dùng để đổi một số tiền N với mệnh giá cố định",
        "points": 200
      },
      {
        "id": "E1",
        "name": "3 Sum",
        "description": "Tìm các bộ ba giá trị có tổng bằng 0",
        "points": 300
      },
      {
        "id": "F1",
        "name": "Sinh Dấu Ngoặc",
        "description": "Sinh tất cả chuỗi dấu ngoặc đúng với n cặp ngoặc",
        "points": 350
      },
      {
        "id": "G1",
        "name": "Kiểm tra BST",
        "description": "Xây dựng cây từ các cạnh mô tả rồi kiểm tra có phải là Binary Search Tree hay không",
        "points": 400
      },
      {
        "id": "H1",
        "name": "Kết Bạn",
        "description": "Tìm kích thước lớn nhất của một nhóm bạn (connected component) trong đồ thị vô hướng",
        "points": 350
      },
      {
        "id": "I1",
        "name": "Xử Lý Yêu Cầu",
        "description": "Xử lý yêu cầu theo độ ưu tiên 'high' trước 'low' nhưng giữ thứ tự đến trong mỗi loại",
        "points": 250
      },
      {
        "id": "J1",
        "name": "Tìm Đường Ngắn Nhất",
        "description": "Tìm đường đi ngắn nhất trên đồ thị vô hướng không trọng số giữa hai đỉnh",
        "points": 500
      },
      {
        "id": "K1",
        "name": "Xếp Đoạn Thẳng",
        "description": "Chọn số lượng đoạn không chồng lấn lớn nhất (activity selection)",
        "points": 300
      },
      {
        "id": "L1",
        "name": "Giả Lập Bàn Phím",
        "description": "Mô phỏng thao tác gõ văn bản với lệnh di chuyển con trỏ và xóa",
        "points": 200
      }
    ],
    "problemDetails": {
      "A1": {
        "name": "Tính Giai Thừa",
        "problemStatement": "Cho một số nguyên không âm n. Hãy tính n! = 1 * 2 * ... * n. Đảm bảo xử lý đúng n = 0 (0! = 1).",
        "inputFormat": "Một dòng chứa một số nguyên không âm n (0 ≤ n ≤ 20).",
        "outputFormat": "Một dòng chứa giá trị giai thừa n! dưới dạng số nguyên thập phân. Không in khoảng trắng thừa hoặc ký tự khác.",
        "constraints": "0 ≤ n ≤ 20. Lý do: 20! = 2432902008176640000 vẫn vừa trong signed 64-bit. Thí sinh nên dùng kiểu 64-bit (long long / int64) hoặc BigInteger nếu ngôn ngữ không hỗ trợ 64-bit chính xác.",
        "sampleInput": [
          "5",
          "0",
          "20"
        ],
        "sampleOutput": [
          "120",
          "1",
          "2432902008176640000"
        ],
        "explanation": "Giải thích chi tiết: Tính tích các số nguyên từ 1 đến n. Với n = 5: 1*2*3*4*5 = 120. Với n = 0 theo định nghĩa 0! = 1. Độ phức tạp: O(n) thời gian, O(1) bộ nhớ. Lưu ý overflow: giới hạn n ≤ 20 để tránh tràn kiểu 64-bit."
      },
      "B1": {
        "name": "Sắp Xếp Hai Mảng",
        "problemStatement": "Cho hai mảng số nguyên A và B. Hãy gộp hai mảng này thành một mảng duy nhất rồi sắp xếp tăng dần tất cả phần tử.",
        "inputFormat": "Dòng 1: hai số nguyên n k (số phần tử của mảng A và B).\nDòng 2: n số nguyên là phần tử mảng A, cách nhau bởi khoảng trắng.\nDòng 3: k số nguyên là phần tử mảng B, cách nhau bởi khoảng trắng.\nLưu ý: n hoặc k có thể bằng 0 (mảng rỗng).",
        "outputFormat": "Một dòng chứa n + k số nguyên đã sắp xếp tăng dần, mỗi số cách nhau một dấu cách. Nếu mảng rỗng in dòng rỗng (không in dấu cách thừa).",
        "constraints": "1 ≤ n, k ≤ 1000 (hoặc n hoặc k có thể bằng 0). Phần tử thuộc phạm vi 32-bit signed. Yêu cầu thuật toán O((n+k) log(n+k)) hoặc O(n+k) nếu dùng merge khi 2 mảng đã có thứ tự ban đầu.",
        "sampleInput": [
          "3 4\n2 1 3\n8 7 9 4",
          "1 0\n5\n",
          "2 2\n-1 0\n0 -1"
        ],
        "sampleOutput": [
          "1 2 3 4 7 8 9",
          "5",
          "-1 -1 0 0"
        ],
        "explanation": "Ví dụ 1: Gộp [2,1,3] và [8,7,9,4] thành [2,1,3,8,7,9,4], sau đó sắp xếp tăng dần. Độ phức tạp: O((n+k) log(n+k)) cho sort chung; nếu 2 mảng ban đầu đã được sắp xếp có thể dùng merge O(n+k). Xử lý trường hợp mảng rỗng và phần tử âm."
      },
      "C1": {
        "name": "Phương Trình Bậc Hai",
        "problemStatement": "Cho các hệ số a, b, c của phương trình bậc hai a x^2 + b x + c = 0 (a, b, c là số nguyên). Hãy xác định nghiệm của phương trình theo các trường hợp:",
        "inputFormat": "Một dòng chứa ba số (a b c) cách nhau bởi khoảng trắng. Các hệ số có thể là số nguyên (−1000 ≤ a, b, c ≤ 1000).",
        "outputFormat": "Tùy trường hợp: \n- Nếu có hai nghiệm thực khác nhau, in hai nghiệm theo thứ tự tăng dần (x1 x2), mỗi nghiệm in với tối đa 6 chữ số sau dấu thập phân.\n- Nếu nghiệm kép, in hai giá trị giống nhau (ví dụ `1.000000 1.000000`) hoặc in một giá trị hai lần theo cùng định dạng.\n- Nếu vô nghiệm thực, in một dòng chứa `Invalid`.\n- Nếu vô số nghiệm (a = b = c = 0), in một dòng chứa `Infinite`.",
        "constraints": "-1000 ≤ a, b, c ≤ 1000. Khi a = 0, bài toán suy biến thành phương trình bậc nhất bx + c = 0 (nếu b ≠ 0). Khi a = b = 0, tuỳ c — vô số nghiệm hoặc vô nghiệm. So sánh discriminant với eps = 1e-12 khi dùng số thực để tránh sai lệch do precision.",
        "sampleInput": [
          "1 -5 6",
          "2 -2 3",
          "0 2 -4",
          "0 0 0"
        ],
        "sampleOutput": [
          "2.000000 3.000000",
          "Invalid",
          "2.000000",
          "Infinite"
        ],
        "explanation": "Trình bày chi tiết: Tính Δ = b^2 - 4ac.\n- Nếu Δ > 0: hai nghiệm thực x1 = (-b - sqrt(Δ))/(2a), x2 = (-b + sqrt(Δ))/(2a) — in theo thứ tự tăng dần.\n- Nếu Δ = 0: nghiệm kép x = -b/(2a) — in lặp lại.\n- Nếu Δ < 0: in 'Invalid'.\n- Nếu a = 0 và b ≠ 0: nghiệm duy nhất x = -c/b (in với 6 chữ số thập phân).\n- Nếu a = b = 0: nếu c = 0 → 'Infinite', ngược lại → 'Invalid'.\nĐộ phức tạp O(1). Lưu ý làm tròn in 6 chữ số để chuẩn hoá output."
      },
      "D1": {
        "name": "Đổi Tiền",
        "problemStatement": "Cho số tiền N, hãy đổi N thành các tờ/mệnh giá tiền có sẵn sao cho số tờ dùng là ít nhất. Giả sử hệ mệnh giá cố định: [100, 50, 20, 10, 5, 2, 1].",
        "inputFormat": "Dòng 1: số nguyên T (số test).\nT dòng tiếp theo: mỗi dòng một số nguyên N (1 ≤ N ≤ 100000).",
        "outputFormat": "T dòng, mỗi dòng một số nguyên biểu thị số tờ tiền ít nhất để dựng N theo mệnh giá cho trước.",
        "constraints": "1 ≤ T ≤ 50, 1 ≤ N ≤ 100000. Vì dãy mệnh giá là chuẩn (100,50,20,10,5,2,1) greedy luôn cho nghiệm tối ưu — thí sinh dùng thuật toán tham lam: lặp qua mệnh giá từ lớn xuống nhỏ, lấy tối đa số tờ có thể tại mỗi mệnh giá.",
        "sampleInput": [
          "2\n70\n121",
          "3\n1\n2\n3"
        ],
        "sampleOutput": [
          "2\n3",
          "1\n1\n2"
        ],
        "explanation": "Ví dụ 1: 70 = 50 + 20 → 2 tờ. 121 = 100 + 20 + 1 → 3 tờ. Ví dụ 2: 1 → 1; 2 → 1 (1 tờ 2); 3 → 2 (2 + 1). Độ phức tạp: O(T * số_mệnh_giá) = O(T * 7)."
      },
      "E1": {
        "name": "3 Sum",
        "problemStatement": "Cho một mảng các số nguyên nums, hãy tìm tất cả các bộ ba các giá trị (a, b, c) sao cho a + b + c = 0. Mỗi bộ ba phải là một tập giá trị (không quan tâm vị trí) và không được lặp lại trong kết quả. Mỗi bộ ba in theo thứ tự tăng dần các phần tử trong nó (a ≤ b ≤ c).",
        "inputFormat": "Một dòng chứa n số nguyên cách nhau bởi dấu cách (3 ≤ n ≤ 3000). Có thể có phần tử trùng nhau. Nếu cần, thí sinh có thể đọc toàn bộ dòng và tách thành danh sách số nguyên.",
        "outputFormat": "In danh sách các bộ ba ở định dạng JSON-like: ví dụ [[-1,-1,2],[-1,0,1]] hoặc mỗi bộ ba một dòng 'a b c'. Giám khảo so sánh tập các bộ ba, không phụ thuộc vào thứ tự in các bộ ba. Nếu không có bộ nào, in [] (một cặp ngoặc vuông).",
        "constraints": "3 ≤ nums.length ≤ 3000, −10^5 ≤ nums[i] ≤ 10^5. Yêu cầu thuật toán O(n^2) thời gian (sử dụng sort + two-pointer) và O(1) bộ nhớ phụ ngoài việc lưu kết quả.",
        "sampleInput": [
          "-1 0 1 2 -1 -4",
          "0 1 1",
          "0 0 0 0"
        ],
        "sampleOutput": [
          "[[-1,-1,2],[-1,0,1]]",
          "[]",
          "[[0,0,0]]"
        ],
        "explanation": "Hướng dẫn chi tiết: sort mảng, duyệt i từ 0..n-3, với mỗi i dùng two-pointer left=i+1, right=n-1 để tìm 2 số còn lại sao cho tổng = -nums[i]. Bỏ qua phần tử trùng để tránh lặp. Độ phức tạp: O(n^2). Các edge-case: toàn bộ phần tử 0 chỉ tạo ra một bộ [0,0,0] dù có nhiều 0."
      },
      "F1": {
        "name": "Sinh Dấu Ngoặc",
        "problemStatement": "Sinh tất cả chuỗi dấu ngoặc đúng (well-formed parentheses) có chính xác n cặp dấu ngoặc '()'.",
        "inputFormat": "Một dòng chứa số nguyên n (1 ≤ n ≤ 8).",
        "outputFormat": "In danh sách các chuỗi hợp lệ. Có thể in dạng JSON array hoặc in mỗi chuỗi trên một dòng. Thứ tự các chuỗi không bắt buộc, nhưng cần đầy đủ và không trùng nhau.",
        "constraints": "1 ≤ n ≤ 8. Số lượng kết quả bằng Catalan(n) — với n = 8 là 1430, vẫn có thể in được trong giới hạn thường dùng cho đề thi lập trình.",
        "sampleInput": [
          "3",
          "1"
        ],
        "sampleOutput": [
          "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "[\"()\"]"
        ],
        "explanation": "Gợi ý: dùng backtracking với 2 tham số cònLeft (số '(' còn được đặt) và cònRight (số ')' có thể đặt -> chỉ đặt ')' khi cònRight > cònLeft). Mỗi đường đi khi cònLeft = 0 và cònRight = 0 là một chuỗi hợp lệ. Độ phức tạp đầu ra lớn (Catalan), thuật toán thường O(Catalan(n) * n) để sinh."
      },
      "G1": {
        "name": "Kiểm tra BST",
        "problemStatement": "Cho N dòng mô tả quan hệ cha-con trong một cây nhị phân: mỗi dòng có 3 phần: parent child side, trong đó side = 'L' cho con trái hoặc 'R' cho con phải. Xây dựng cây từ mô tả và kiểm tra xem cây có phải là Binary Search Tree (BST) với điều kiện nghiêm ngặt: mọi node bên trái < node gốc < mọi node bên phải (không cho phép bằng).",
        "inputFormat": "Một test bao gồm:\nDòng 1: số nguyên N (số quan hệ mô tả).\nN dòng tiếp: mỗi dòng 3 phần: parent child side (ví dụ: 10 5 L).\nGiả định input mô tả đúng một cây nối liên thông (không có vòng). Nếu input có mâu thuẫn (ví dụ một node có hai cha khác nhau), có thể coi là không phải BST và in 'false'.",
        "outputFormat": "In 'true' nếu cấu trúc là BST theo quy ước strict, ngược lại in 'false'.",
        "constraints": "1 ≤ N ≤ 1000. Giá trị các node thuộc kiểu số nguyên (không giới hạn cụ thể). Kiểm tra bằng cách duyệt (recursively) và truyền khoảng (min,max) tại mỗi node: node->value phải nằm trong (min, max).",
        "sampleInput": [
          "6\n10 5 L\n10 15 R\n5 3 L\n5 7 R\n15 12 L\n15 18 R",
          "2\n10 15 L\n10 5 R"
        ],
        "sampleOutput": [
          "true",
          "false"
        ],
        "explanation": "Xây cây theo quan hệ, xác định root (node không xuất hiện là child). Kiểm tra: với mỗi node có giá trị v, mọi node con trái phải < v, con phải > v. Dùng đệ quy hoặc duyệt in-order kiểm tra tăng dần. Edge-case: các giá trị trùng lặp vi phạm strict BST. Nếu cấu trúc mâu thuẫn, trả false."
      },
      "H1": {
        "name": "Kết Bạn",
        "problemStatement": "Cho đồ thị vô hướng biểu diễn mối quan hệ bạn bè giữa N người (đánh số từ 1 đến N) và M cạnh (u v). Hãy tìm kích thước (số node) của component liên thông lớn nhất trong đồ thị đó.",
        "inputFormat": "Dòng 1: số nguyên T (số test). Với mỗi test: một dòng chứa N M; tiếp theo M dòng mỗi dòng hai số nguyên u v (1 ≤ u, v ≤ N) biểu diễn một cạnh vô hướng.\nCác test độc lập nhau.",
        "outputFormat": "T dòng, mỗi dòng in một số nguyên là kích thước component lớn nhất tương ứng với test đó.",
        "constraints": "T ≤ 20; với mỗi test 1 ≤ N, M ≤ 10^5; tổng N và M qua tất cả test không vượt quá 10^6. Yêu cầu dùng BFS/DFS hoặc Union-Find để đạt hiệu năng. Bộ nhớ phải phù hợp để lưu danh sách kề.",
        "sampleInput": [
          "2\n3 2\n1 2\n2 3\n10 12\n1 2\n3 1\n3 4\n5 4\n3 5\n4 6\n5 2\n2 1\n7 1\n1 2\n9 10\n8 9"
        ],
        "sampleOutput": [
          "3\n7"
        ],
        "explanation": "Dùng Union-Find hoặc DFS để gom các node theo component và đếm kích thước của mỗi component. Ví dụ test 1: các node 1-2-3 liên thông → kích thước 3. Test 2 theo dữ liệu mẫu lớn hơn trả 7. Edge-case: nếu M = 0 thì component lớn nhất = 1 (nếu N > 0)."
      },
      "I1": {
        "name": "Xử Lý Yêu Cầu",
        "problemStatement": "Có N yêu cầu đến theo thứ tự (đánh số vị trí từ 1 đến N). Mỗi yêu cầu có loại 'high' hoặc 'low'. Hệ thống sẽ xử lý toàn bộ các yêu cầu loại 'high' trước (theo thứ tự đến của các 'high'), rồi sau đó xử lý các 'low' theo thứ tự đến của chúng. Hãy in ra thứ tự (các chỉ số ban đầu) mà hệ thống xử lý các yêu cầu.",
        "inputFormat": "Dòng 1: N (1 ≤ N ≤ 10^5).\nDòng 2: N token, mỗi token là chuỗi 'high' hoặc 'low' (phân biệt chữ thường). Các token cách nhau bởi dấu cách. Có thể có nhiều test — nếu muốn mở rộng frame, thêm T.",
        "outputFormat": "Một dòng gồm N số nguyên (các chỉ số ban đầu từ 1..N) theo thứ tự xử lý, mỗi số cách nhau một dấu cách.",
        "constraints": "1 ≤ N ≤ 10^5. Thực hiện bằng cách duyệt một lần: lưu chỉ số của các 'high' vào queueHigh theo thứ tự xuất hiện, lưu chỉ số các 'low' vào queueLow. Kết quả = queueHigh nối queueLow. Độ phức tạp O(N).",
        "sampleInput": [
          "5\nlow high low high low",
          "3\nhigh high low"
        ],
        "sampleOutput": [
          "2 4 1 3 5",
          "1 2 3"
        ],
        "explanation": "Ví dụ 1: các 'high' xuất hiện ở vị trí 2 và 4 → xử lý trước: [2,4]; sau đó các 'low' vị trí [1,3,5] → nối lại [2,4,1,3,5]. Cách làm: 1 pass lưu 2 hàng đợi."
      },
      "J1": {
        "name": "Tìm Đường Ngắn Nhất",
        "problemStatement": "Cho đồ thị vô hướng không trọng số. Mỗi test gồm N (số đỉnh), M (số cạnh) và Q truy vấn; mỗi truy vấn yêu cầu khoảng cách (số cạnh) nhỏ nhất giữa hai đỉnh A và B. Hãy trả về độ dài đường đi ngắn nhất cho từng truy vấn; nếu không có đường đi, in -1 (hoặc một giá trị biểu diễn không liên thông).",
        "inputFormat": "Dòng 1: số nguyên T (số test). Với mỗi test: một dòng chứa N M Q. Tiếp theo M dòng là các cạnh u v (1 ≤ u,v ≤ N). Tiếp Q dòng mỗi dòng là truy vấn A B.\nLưu ý: đồ thị có thể lớn (N ≤ 100000, M ≤ 200000), nhưng Q ≤ 1000 cho mỗi test để cho phép BFS cho mỗi truy vấn nếu cần tối ưu thêm có thể dùng multi-source BFS hoặc tiền xử lý theo thành phần liên thông.",
        "outputFormat": "Với mỗi truy vấn in một dòng chứa một số nguyên là số cạnh ít nhất giữa A và B; nếu không có đường đi in -1.",
        "constraints": "1 ≤ T ≤ 20, N ≤ 100000, M ≤ 200000, Q ≤ 1000. Thời gian yêu cầu: cho mỗi truy vấn BFS O(N+M) có thể chấp nhận được nếu Q nhỏ; nếu Q lớn cần tối ưu (precompute distances, multi-source, hoặc dùng thuật toán theo từng thành phần).",
        "sampleInput": [
          "1\n4 3 2\n1 2\n2 3\n3 4\n1 4\n4 1"
        ],
        "sampleOutput": [
          "3\n3"
        ],
        "explanation": "Ví dụ: đồ thị chuỗi 1-2-3-4. Độ dài ngắn nhất từ 1 đến 4 = 3 cạnh. Tương tự 4 đến 1 = 3. Gợi ý: dùng BFS từ đỉnh nguồn cho mỗi truy vấn; trong trường hợp nhiều truy vấn, có thể gom theo nguồn chung để tái sử dụng BFS."
      },
      "K1": {
        "name": "Xếp Đoạn Thẳng",
        "problemStatement": "Cho N đoạn trên trục (mỗi đoạn cho bởi 2 số start end). Hãy chọn tập con lớn nhất các đoạn sao cho không có hai đoạn nào chồng lấn (intersect) về khoảng mở/trong đóng tùy quy ước; ta dùng quy ước không chồng lấn là end_i ≤ start_j cho các đoạn được chọn theo thứ tự thời gian kết thúc tăng dần.",
        "inputFormat": "Dòng 1: T (số test). Với mỗi test: một dòng chứa N. Tiếp theo N dòng mỗi dòng 2 số nguyên start end (có thể start ≤ end).",
        "outputFormat": "T dòng, mỗi dòng một số nguyên là số đoạn tối đa không chồng lấn cho test tương ứng.",
        "constraints": "N ≤ 10^5 cho mỗi test, T ≤ 10; tổng N qua toàn bộ input ≤ 10^6. Thuật toán chuẩn: sắp xếp các đoạn theo điểm kết thúc tăng dần, sau đó chọn greedy O(N log N) cho sắp xếp + O(N) cho lựa chọn.",
        "sampleInput": [
          "1\n10\n39 55\n37 74\n0 1\n19 25\n65 76\n51 52\n19 21\n5 94\n46 65\n32 40"
        ],
        "sampleOutput": [
          "5"
        ],
        "explanation": "Sắp xếp theo end: chọn đoạn kết thúc nhỏ nhất trước, bỏ các đoạn giao nhau với đoạn đã chọn. Đây là bài toán Activity Selection. Độ phức tạp: O(N log N)."
      },
      "L1": {
        "name": "Giả Lập Bàn Phím",
        "problemStatement": "Mô phỏng thao tác gõ văn bản với các ký tự thông thường và các lệnh điều khiển: '<' = di chuyển con trỏ sang trái (nếu có thể), '>' = di chuyển con trỏ sang phải (nếu có thể), '-' = xóa ký tự đứng ngay trước con trỏ (backspace). Mọi ký tự khác (chữ, số, ký tự đặc biệt) được chèn vào vị trí con trỏ và con trỏ dịch sang phải 1 vị trí.",
        "inputFormat": "Một dòng chứa một chuỗi ký tự biểu diễn các thao tác (độ dài ≤ 10^6). Chuỗi gồm các ký tự ASCII in được và các ký tự điều khiển '<', '>', '-'.",
        "outputFormat": "Một dòng chứa kết quả (chuỗi ký tự) sau khi thực hiện tuần tự tất cả thao tác từ trái sang phải. Không in ký tự điều khiển — chỉ in nội dung cuối cùng của text buffer.",
        "constraints": "Độ dài chuỗi ≤ 10^6. Yêu cầu dùng cấu trúc 2 stack hoặc deque để mô phỏng con trỏ hiệu quả O(n).",
        "sampleInput": [
          "<<PI<T>>Ta-"
        ],
        "sampleOutput": [
          "PTIT"
        ],
        "explanation": "Giải thích mẫu: bắt đầu từ rỗng. Duyệt chuỗi: '<' (không làm gì nếu con trỏ ở đầu), '<' (vẫn đầu), 'P' → chèn 'P', 'I' → chèn 'I', '<' → con trỏ lùi 1, 'T' → chèn 'T' vào giữa, '>' → con trỏ dịch phải, '>' → tiếp, 'T' → chèn 'T', 'a' → chèn 'a', '-' → xóa ký tự trước con trỏ (xóa 'a'). Kết quả cuối cùng sau sắp xếp các thao tác là \"PTPT\". Gợi ý cài đặt: dùng hai stack left và right; chèn: push lên left; '<': nếu left không rỗng pop sang right; '>': nếu right không rỗng pop sang left; '-': nếu left không rỗng pop left. Sau khi xử lý, nối left + reversed(right) để tạo kết quả."     
      }
    }
  }
}